#Function that calculates ED between one major type and the rest
compute.ed.between <- function(majortype_indices, ed_within_df) {
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Replace the EDs computed within the majortype with the already computed ones
ed_between[[majortype_indices]] <- ed_within_df[[majortype_indices]]
#Bind the data frames together
data <- do.call(rbind, ed_between)
#Reset the row names
rownames(data) <- NULL
return(majortype_indices)
#return(data)
}
#Compute ED between all major types
list_ed_between <- lapply(1:n_mtypes, function(i) compute.ed.between(i, ed_within))
#Function that calculates ED between one major type and the rest
compute.ed.between <- function(majortype_indices, ed_within_df) {
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Replace the EDs computed within the majortype with the already computed ones
ed_between[[majortype_indices]] <- ed_within_df[[majortype_indices]]
#Bind the data frames together
data <- do.call(rbind, ed_between)
#Reset the row names
rownames(data) <- NULL
print(majortype_indices)
#return(data)
}
#Compute ED between all major types
list_ed_between <- lapply(1:n_mtypes, function(i) compute.ed.between(i, ed_within))
!is.na(strong_LCE[i])
majortype_indices
majortype_indices <- 35
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Replace the EDs computed within the majortype with the already computed ones
ed_between[[majortype_indices]] <- ed_within_df[[majortype_indices]]
#Bind the data frames together
data <- do.call(rbind, ed_between)
#Reset the row names
rownames(data) <- NULL
for (b in 1:60) {
majortype_indices <- b
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
}
for (b in 1:60) {
majortype_indices <- b
print(b)
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
}
majortype_indices <- 1
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
ed_between
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified,
#then check whether major types are conditional on different LCEs
if (!is.na(strong_LCE[i]) && strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
i=35
!is.na(strong_LCE[i])
strong_LCE[majortype_indices]
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified
if(!is.na(strong_LCE[majortype_indices]) && !is.na(strong_LCE[i])) {
#Then check whether major types are conditional on different LCEs
if (strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Function that calculates ED between one major type and the rest
compute.ed.between <- function(majortype_indices, ed_within_df) {
#Generate indices to apply the distance calculation to
index_pairs <- expand.grid(1:n_mtypes, majortype_indices)
#Apply the distance calculation to the indexed elements in the list (LCE with zero values are irrelevant)
ed_bs <- mapply(function(i, j) {
custom.distance(x = bs_list[[i]], y = bs_list[[j]], exclude_irrelevant = TRUE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
#Apply the distance calculation to the indexed elements in the list
ed_dlce <- mapply(function(i, j) {
custom.distance(x = dlce_list[[i]], y = dlce_list[[j]], exclude_irrelevant = FALSE)
}, index_pairs[[1]], index_pairs[[2]], SIMPLIFY = FALSE)
# Add ED from basic steps and defining LCEs
ed_between <- mapply(function(x, y) {
x + y
}, ed_bs, ed_dlce, SIMPLIFY = FALSE)
#Add 2 ED units if the major types belong to different major-type groups
ed_between <- lapply(seq_along(ed_between), function(i) {
if (major_type_group[majortype_indices] != major_type_group[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
#If one of the major types are terrestrial subtract ED units if the mapping unit is influenced by water
if(major_type_group[majortype_indices] == 1 || major_type_group[i] == 1) {
#Subtract ED units if the mapping unit is influenced by spring water, inundation, or water disturbance
subtraction <- rowSums(dlce_list[[i]][,c(4,6,11)])
#Subtract one ED unit at maximum
ed_between[[i]] <- ed_between[[i]] - pmin(1, subtraction)
}
}
return(ed_between[[i]])
})
#Add 2 ED units per anthropogenic influence step
ed_between <- lapply(seq_along(ed_between), function(i) {
#Calculate the absolute number of steps of anthropogenic influence
difference <- abs(anthropogenic_influence[majortype_indices] - anthropogenic_influence[i])
#Add the number of steps times two
ed_between[[i]] <- ed_between[[i]] + difference * 2
return(ed_between[[i]])
})
#Add 2 ED units if the structuring species groups differ between major types
ed_between <- lapply(seq_along(ed_between), function(i) {
if (structuring_species[majortype_indices] != structuring_species[i]) {
ed_between[[i]] <- ed_between[[i]] + 2
}
return(ed_between[[i]])
})
#Add 1 ED unit if the major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
if (factor_LCE[majortype_indices] != factor_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
return(ed_between[[i]])
})
#Add 1 ED unit if strongly modified major types are conditional on different LCEs
ed_between <- lapply(seq_along(ed_between), function(i) {
#If statement to first check that the major type is strongly modified
if(!is.na(strong_LCE[majortype_indices]) && !is.na(strong_LCE[i])) {
#Then check whether major types are conditional on different LCEs
if (strong_LCE[majortype_indices] != strong_LCE[i]) {
ed_between[[i]] <- ed_between[[i]] + 1
}
}
return(ed_between[[i]])  # Return the modified or unmodified data frame
})
#Replace the EDs computed within the majortype with the already computed ones
ed_between[[majortype_indices]] <- ed_within_df[[majortype_indices]]
#Bind the data frames together
data <- do.call(rbind, ed_between)
#Reset the row names
rownames(data) <- NULL
return(data)
}
#Compute ED between all major types
list_ed_between <- lapply(1:n_mtypes, function(i) compute.ed.between(i, ed_within))
list_ed_between
#Bind data frames together
ed_between <- do.call(cbind, list_ed_between)
ed_between
#Rename columns
colnames(ed_between) <- c("T1-C-1",	"T1-C-2",	"T1-C-3",	"T1-C-4",	"T1-C-5",	"T1-C-6",	"T1-C-7",	"T1-C-8",	"T1-C-9",	"T1-C-10",	"T1-C-11",	"T1-C-12",	"T2-C-1",	"T2-C-2",	"T2-C-3",	"T2-C-4",	"T2-C-5",	"T2-C-6",	"T2-C-7",	"T2-C-8",	"T3-C-1",	"T3-C-2",	"T3-C-3",	"T3-C-4",	"T3-C-5",	"T3-C-6",	"T3-C-7",	"T3-C-8",	"T3-C-9",	"T3-C-10",	"T3-C-11",	"T3-C-12",	"T3-C-13",	"T3-C-14",	"T4-C-1",	"T4-C-2",	"T4-C-3",	"T4-C-4",	"T4-C-5",	"T4-C-6",	"T4-C-7",	"T4-C-8",	"T4-C-9",	"T4-C-10",	"T4-C-11",	"T4-C-12",	"T4-C-13",	"T4-C-14",	"T4-C-15",	"T4-C-16",	"T4-C-17",	"T4-C-18",	"T4-C-19",	"T4-C-20",	"T5-C-1",	"T5-C-2",	"T5-C-3",	"T5-C-4",	"T5-C-5",	"T5-C-6",	"T5-C-7",	"T6-C-1",	"T6-C-2",	"T7-C-1",	"T7-C-2",	"T7-C-3",	"T7-C-4",	"T7-C-5",	"T7-C-6",	"T7-C-7",	"T7-C-8",	"T7-C-9",	"T7-C-10",	"T7-C-11",	"T7-C-12",	"T7-C-13",	"T7-C-14",	"T8-C-1",	"T8-C-2",	"T8-C-3",	"T9-C-1",	"T9-C-2",	"T10-C-1",	"T11-C-1",	"T11-C-2",	"T12-C-1",	"T12-C-2",	"T13-C-1",	"T13-C-2",	"T13-C-3",	"T13-C-4",	"T13-C-5",	"T13-C-6",	"T13-C-7",	"T13-C-8",	"T13-C-9",	"T13-C-10",	"T13-C-11",	"T13-C-12",	"T13-C-13",	"T13-C-14",	"T13-C-15",	"T14-C-1",	"T14-C-2",	"T15-C-1",	"T15-C-2",	"T16-C-1",	"T16-C-2",	"T16-C-3",	"T16-C-4",	"T16-C-5",	"T16-C-6",	"T16-C-7",	"T17-C-1",	"T17-C-2",	"T17-C-3",	"T18-C-1",	"T18-C-2",	"T18-C-3",	"T18-C-4",	"T19-C-1",	"T19-C-2",	"T20-C-1",	"T20-C-2",	"T21-C-1",	"T21-C-2",	"T21-C-3",	"T21-C-4",	"T22-C-1",	"T22-C-2",	"T22-C-3",	"T22-C-4",	"T23-C-1",	"T24-C-1",	"T24-C-2",	"T25-C-1",	"T25-C-2",	"T25-C-3",	"T26-C-1",	"T26-C-2",	"T26-C-3",	"T26-C-4",	"T27-C-1",	"T27-C-2",	"T27-C-3",	"T27-C-4",	"T27-C-5",	"T27-C-6",	"T27-C-7",	"T28-C-1",	"T28-C-2",	"T28-C-3",	"T29-C-1",	"T29-C-2",	"T29-C-3",	"T29-C-4",	"T29-C-5",	"T29-C-6",	"T30-C-1",	"T30-C-2",	"T30-C-3",	"T30-C-4",	"T31-C-1",	"T31-C-2",	"T31-C-3",	"T31-C-4",	"T31-C-5",	"T31-C-6",	"T31-C-7",	"T31-C-8",	"T31-C-9",	"T31-C-10",	"T31-C-11",	"T31-C-12",	"T31-C-13",	"T31-C-14",	"T32-C-1",	"T32-C-2",	"T32-C-3",	"T32-C-4",	"T32-C-5",	"T32-C-6",	"T32-C-7",	"T32-C-8",	"T32-C-9",	"T32-C-10",	"T32-C-11",	"T32-C-12",	"T32-C-13",	"T32-C-14",	"T32-C-15",	"T32-C-16",	"T32-C-17",	"T32-C-18",	"T32-C-19",	"T32-C-20",	"T32-C-21",	"T33-C-1",	"T33-C-2",	"T34-C-1",	"T34-C-2",	"T34-C-3",	"T34-C-4",	"T34-C-5",	"T34-C-6",	"T35-C-1",	"T35-C-2",	"T35-C-3",	"T36-C-1",	"T36-C-2",	"T36-C-3",	"T37-C-1",	"T37-C-2",	"T37-C-3",	"T38-C-1",	"T39-C-1",	"T39-C-2",	"T39-C-3",	"T39-C-4",	"T40-C-1",	"T41-C-1",	"T42-C-1",	"T43-C-1",	"T44-C-1",	"T45-C-1",	"T45-C-2",	"T45-C-3",	"V1-C-1",	"V1-C-2",	"V1-C-3",	"V1-C-4",	"V1-C-5",	"V1-C-6",	"V1-C-7",	"V1-C-8",	"V1-C-9",	"V2-C-1",	"V2-C-2",	"V2-C-3",	"V3-C-1",	"V3-C-2",	"V4-C-1",	"V4-C-2",	"V4-C-3",	"V4-C-4",	"V4-C-5",	"V5-C-1",	"V5-C-2",	"V6-C-1",	"V6-C-2",	"V6-C-3",	"V6-C-4",	"V6-C-5",	"V6-C-6",	"V6-C-7",	"V6-C-8",	"V6-C-9",	"V7-C-1",	"V7-C-2",	"V8-C-1",	"V8-C-2",	"V8-C-3",	"V9-C-1",	"V9-C-2",	"V9-C-3",	"V10-C-1",	"V10-C-2",	"V10-C-3",	"V11-C-1",	"V11-C-2",	"V12-C-1",	"V12-C-2",	"V12-C-3",	"V13-C-1",	"V13-C-2",	"V13-C-3",	"V13-C-4",	"L4-C-1",	"L4-C-2",	"L4-C-3",	"L")
ed_between
ed <- as.data.frame(read_xlsx("../matrices/ED5.xlsx"))
ed - ed_between
floor(ed_between)
#Compare results
ed - floor(ed_between)
ed_within
lapply(ed_within, 0)
ed_within
lapply(ed_within, function(data) {
#Assign zero to all the values in each data frame
data[,] <- 0
return(data)
})
